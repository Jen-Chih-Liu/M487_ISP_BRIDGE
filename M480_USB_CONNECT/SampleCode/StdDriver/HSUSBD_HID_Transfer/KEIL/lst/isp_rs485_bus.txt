; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\obj\isp_rs485_bus.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\isp_rs485_bus.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\..\Library\CMSIS\Include -I..\..\..\..\Library\StdDriver\inc -I..\..\..\..\Library\Device\Nuvoton\M480\Include -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 -DDEBUG_ENABLE_SEMIHOST --omf_browse=.\obj\isp_rs485_bus.crf ..\ISP_RS485_BUS.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  SendChar_ToRS485 PROC
;;;8      #define RS458_TX_DISABLE PH2=0
;;;9      void SendChar_ToRS485(uint8_t u8InChar)
000000  bf00              NOP      
                  |L1.2|
;;;10     {
;;;11         
;;;12         while(UART_IS_TX_FULL(UART5)){};  /* Wait Tx is not full to transmit data */
000002  4950              LDR      r1,|L1.324|
000004  6989              LDR      r1,[r1,#0x18]
000006  f3c151c0          UBFX     r1,r1,#23,#1
00000a  2900              CMP      r1,#0
00000c  d1f9              BNE      |L1.2|
;;;13               UART_WRITE(UART5, u8InChar);
00000e  494d              LDR      r1,|L1.324|
000010  6008              STR      r0,[r1,#0]
;;;14     	  while(UART_IS_TX_EMPTY(UART5)==0);  /* Wait Tx is not full to transmit data */
000012  bf00              NOP      
                  |L1.20|
000014  494b              LDR      r1,|L1.324|
000016  6989              LDR      r1,[r1,#0x18]
000018  f3c17100          UBFX     r1,r1,#28,#1
00001c  2900              CMP      r1,#0
00001e  d0f9              BEQ      |L1.20|
;;;15     	  
;;;16     }
000020  4770              BX       lr
;;;17     
                          ENDP

                  RS485_WRITE PROC
;;;18     
;;;19     ErrNo RS485_WRITE(io_handle_t handle, const void *buf, uint32 *len)
000022  b5f0              PUSH     {r4-r7,lr}
;;;20     {
000024  4607              MOV      r7,r0
000026  460b              MOV      r3,r1
000028  4614              MOV      r4,r2
;;;21     	uint8_t *pTxData;
;;;22     	uint32 txlen=*len;
00002a  6826              LDR      r6,[r4,#0]
;;;23     	pTxData = (uint8_t *)buf;
00002c  461d              MOV      r5,r3
;;;24     	RS458_TX_ENEABLE;
00002e  2001              MOVS     r0,#1
000030  4945              LDR      r1,|L1.328|
000032  6008              STR      r0,[r1,#0]
;;;25     	for (int i = 0; i < txlen; i++)
000034  2200              MOVS     r2,#0
000036  e003              B        |L1.64|
                  |L1.56|
;;;26     	     SendChar_ToRS485(pTxData[i]);		
000038  5ca8              LDRB     r0,[r5,r2]
00003a  f7fffffe          BL       SendChar_ToRS485
00003e  1c52              ADDS     r2,r2,#1              ;25
                  |L1.64|
000040  42b2              CMP      r2,r6                 ;25
000042  d3f9              BCC      |L1.56|
;;;27         RS458_TX_DISABLE;		 
000044  2000              MOVS     r0,#0
000046  4940              LDR      r1,|L1.328|
000048  6008              STR      r0,[r1,#0]
;;;28     	return ENOERR;
;;;29     }
00004a  bdf0              POP      {r4-r7,pc}
;;;30     
                          ENDP

                  RS485_READ PROC
;;;31     ErrNo RS485_READ(io_handle_t handle, void *buf, uint32 *len)
00004c  e92d47f0          PUSH     {r4-r10,lr}
;;;32     {
000050  4682              MOV      r10,r0
000052  460d              MOV      r5,r1
000054  4616              MOV      r6,r2
;;;33     	
;;;34     	uint8_t *pRxData;
;;;35     	uint32 rxlen = *len;
000056  f8d69000          LDR      r9,[r6,#0]
;;;36     	pRxData = (uint8_t *)buf;
00005a  46a8              MOV      r8,r5
;;;37     	uint32_t time_count=0;
00005c  2700              MOVS     r7,#0
;;;38     	TIMER_Open(TIMER0, TIMER_PERIODIC_MODE, 1);
00005e  2201              MOVS     r2,#1
000060  06d1              LSLS     r1,r2,#27
000062  483a              LDR      r0,|L1.332|
000064  f7fffffe          BL       TIMER_Open
;;;39         TIMER_Start(TIMER0);
000068  bf00              NOP      
00006a  4838              LDR      r0,|L1.332|
00006c  6800              LDR      r0,[r0,#0]
00006e  f0404080          ORR      r0,r0,#0x40000000
000072  4936              LDR      r1,|L1.332|
000074  6008              STR      r0,[r1,#0]
000076  bf00              NOP      
;;;40     	for (int i = 0; i < rxlen; i++)
000078  2400              MOVS     r4,#0
00007a  e021              B        |L1.192|
                  |L1.124|
;;;41        {
;;;42     		 while(1)
00007c  e01d              B        |L1.186|
                  |L1.126|
;;;43     		 {
;;;44     		 if(UART_IS_RX_READY(UART5))
00007e  4831              LDR      r0,|L1.324|
000080  69c0              LDR      r0,[r0,#0x1c]
000082  f0000001          AND      r0,r0,#1
000086  b120              CBZ      r0,|L1.146|
;;;45     		 {
;;;46     		 pRxData[i]=UART_READ(UART5);
000088  482e              LDR      r0,|L1.324|
00008a  6800              LDR      r0,[r0,#0]
00008c  f8080004          STRB     r0,[r8,r4]
;;;47     			 break;
000090  e014              B        |L1.188|
                  |L1.146|
;;;48     		 }
;;;49     		 
;;;50     		if(TIMER_GetIntFlag(TIMER0))
000092  bf00              NOP      
000094  482d              LDR      r0,|L1.332|
000096  6880              LDR      r0,[r0,#8]
000098  f0000001          AND      r0,r0,#1
00009c  b168              CBZ      r0,|L1.186|
;;;51     			 {
;;;52     				
;;;53     		/* Clear Timer0 time-out interrupt flag */
;;;54             TIMER_ClearIntFlag(TIMER0);
00009e  bf00              NOP      
0000a0  2001              MOVS     r0,#1
0000a2  492a              LDR      r1,|L1.332|
0000a4  6088              STR      r0,[r1,#8]
0000a6  bf00              NOP      
;;;55     				time_count++;
0000a8  1c7f              ADDS     r7,r7,#1
;;;56     				if(time_count>=uart_timeout) 
0000aa  2f0a              CMP      r7,#0xa
0000ac  d305              BCC      |L1.186|
;;;57     				{
;;;58     					TIMER_Stop(TIMER0);
0000ae  4608              MOV      r0,r1
0000b0  f7fffffe          BL       TIMER_Stop
;;;59     					return ETO; //THIS IS TIMEOUT ERROR
0000b4  2005              MOVS     r0,#5
                  |L1.182|
;;;60     		   } 
;;;61     		 
;;;62     	 }
;;;63      }
;;;64     		 }
;;;65     
;;;66     TIMER_Stop(TIMER0);
;;;67        
;;;68     	return ENOERR;
;;;69     }
0000b6  e8bd87f0          POP      {r4-r10,pc}
                  |L1.186|
0000ba  e7e0              B        |L1.126|
                  |L1.188|
0000bc  bf00              NOP                            ;47
0000be  1c64              ADDS     r4,r4,#1              ;40
                  |L1.192|
0000c0  454c              CMP      r4,r9                 ;40
0000c2  d3db              BCC      |L1.124|
0000c4  4821              LDR      r0,|L1.332|
0000c6  f7fffffe          BL       TIMER_Stop
0000ca  2000              MOVS     r0,#0                 ;68
0000cc  e7f3              B        |L1.182|
;;;70     
                          ENDP

                  RS485_Config PROC
;;;72     
;;;73     ErrNo RS485_Config(void *priv)
0000ce  b510              PUSH     {r4,lr}
;;;74     {
0000d0  4604              MOV      r4,r0
;;;75     		    /* Enable UART module clock */
;;;76         CLK_EnableModuleClock(UART5_MODULE);
0000d2  481f              LDR      r0,|L1.336|
0000d4  f7fffffe          BL       CLK_EnableModuleClock
;;;77     
;;;78     
;;;79         /* Select UART clock source is HXT */
;;;80         CLK_SetModuleClock(UART5_MODULE, CLK_CLKSEL3_UART5SEL_HXT, 0);
0000d8  2200              MOVS     r2,#0
0000da  4611              MOV      r1,r2
0000dc  481c              LDR      r0,|L1.336|
0000de  f7fffffe          BL       CLK_SetModuleClock
;;;81     
;;;82         /* Set GPB multi-function pins for UART5 RXD and TXD */
;;;83         SYS->GPH_MFPL &= ~(SYS_GPH_MFPL_PH0MFP_Msk | SYS_GPH_MFPL_PH1MFP_Msk);
0000e2  f04f4080          MOV      r0,#0x40000000
0000e6  6e80              LDR      r0,[r0,#0x68]
0000e8  f02000ff          BIC      r0,r0,#0xff
0000ec  f04f4180          MOV      r1,#0x40000000
0000f0  6688              STR      r0,[r1,#0x68]
;;;84         SYS->GPH_MFPL |= (SYS_GPH_MFPL_PH0MFP_UART5_TXD) | (SYS_GPH_MFPL_PH1MFP_UART5_RXD);
0000f2  4608              MOV      r0,r1
0000f4  6e80              LDR      r0,[r0,#0x68]
0000f6  f0400044          ORR      r0,r0,#0x44
0000fa  6688              STR      r0,[r1,#0x68]
;;;85          
;;;86     		    /* Configure UART5 and set UART5 baud rate */
;;;87         UART_Open(UART5, 115200);
0000fc  f44f31e1          MOV      r1,#0x1c200
000100  4810              LDR      r0,|L1.324|
000102  f7fffffe          BL       UART_Open
;;;88     	    CLK_EnableModuleClock(TMR0_MODULE);
000106  4813              LDR      r0,|L1.340|
000108  f7fffffe          BL       CLK_EnableModuleClock
;;;89     
;;;90         /* Select IP clock source */
;;;91         CLK_SetModuleClock(UART5_MODULE, CLK_CLKSEL3_UART5SEL_HXT, CLK_CLKDIV0_UART0(1));
00010c  2200              MOVS     r2,#0
00010e  4611              MOV      r1,r2
000110  480f              LDR      r0,|L1.336|
000112  f7fffffe          BL       CLK_SetModuleClock
;;;92         CLK_SetModuleClock(TMR0_MODULE, CLK_CLKSEL1_TMR0SEL_HXT, 0);
000116  2200              MOVS     r2,#0
000118  4611              MOV      r1,r2
00011a  480e              LDR      r0,|L1.340|
00011c  f7fffffe          BL       CLK_SetModuleClock
;;;93     	  
;;;94     			    /* Configure PB.2 as Output mode for RS485 transfer*/
;;;95         GPIO_SetMode(PH, BIT2, GPIO_MODE_OUTPUT);
000120  2201              MOVS     r2,#1
000122  2104              MOVS     r1,#4
000124  480c              LDR      r0,|L1.344|
000126  f7fffffe          BL       GPIO_SetMode
;;;96     		PH2=0;//RS485 RECIVER.
00012a  2000              MOVS     r0,#0
00012c  4906              LDR      r1,|L1.328|
00012e  6008              STR      r0,[r1,#0]
;;;97     		return ENOERR;
;;;98     }
000130  bd10              POP      {r4,pc}
;;;99     
                          ENDP

                  RS485_Package PROC
;;;100    ErrNo RS485_Package(io_handle_t handle, void *buf, uint32 *len)
000132  4603              MOV      r3,r0
;;;101    {
;;;102    return ENOERR;
000134  2000              MOVS     r0,#0
;;;103    
;;;104    }
000136  4770              BX       lr
;;;105    
                          ENDP

                  TIMER_Stop PROC
;;;169      */
;;;170    __STATIC_INLINE void TIMER_Stop(TIMER_T *timer)
000138  6801              LDR      r1,[r0,#0]
;;;171    {
;;;172        timer->CTL &= ~TIMER_CTL_CNTEN_Msk;
00013a  f0214180          BIC      r1,r1,#0x40000000
00013e  6001              STR      r1,[r0,#0]
;;;173    }
000140  4770              BX       lr
;;;174    
                          ENDP

000142  0000              DCW      0x0000
                  |L1.324|
                          DCD      0x40075000
                  |L1.328|
                          DCD      0x400049c8
                  |L1.332|
                          DCD      0x40050000
                  |L1.336|
                          DCD      0x77ec3d95
                  |L1.340|
                          DCD      0x5e800002
                  |L1.344|
                          DCD      0x400041c0

;*** Start embedded assembler ***

#line 1 "..\\ISP_RS485_BUS.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_ISP_RS485_BUS_c_e31ea898____REV16|
#line 388 "..\\..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___15_ISP_RS485_BUS_c_e31ea898____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_ISP_RS485_BUS_c_e31ea898____REVSH|
#line 402
|__asm___15_ISP_RS485_BUS_c_e31ea898____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_ISP_RS485_BUS_c_e31ea898____RRX|
#line 587
|__asm___15_ISP_RS485_BUS_c_e31ea898____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
