; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\obj\isp_i2c_bus.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\isp_i2c_bus.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\..\Library\CMSIS\Include -I..\..\..\..\Library\StdDriver\inc -I..\..\..\..\Library\Device\Nuvoton\M480\Include -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 -DDEBUG_ENABLE_SEMIHOST --omf_browse=.\obj\isp_i2c_bus.crf ..\ISP_I2C_BUS.C]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  I2C_WRITE PROC
;;;6      
;;;7      ErrNo I2C_WRITE(io_handle_t handle, const void *buf, uint32 *len)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;8      {
000004  4681              MOV      r9,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;9      	unsigned char *pTxData;
;;;10     	uint32 txlen=*len;
00000a  f8d68000          LDR      r8,[r6,#0]
;;;11     	pTxData = (unsigned char *)buf;
00000e  462f              MOV      r7,r5
;;;12     
;;;13     	I2C_SET_CONTROL_REG(I2C0, I2C_CTL_STA);
000010  486e              LDR      r0,|L1.460|
000012  6800              LDR      r0,[r0,#0]
000014  f020003c          BIC      r0,r0,#0x3c
000018  f0400020          ORR      r0,r0,#0x20
00001c  496b              LDR      r1,|L1.460|
00001e  6008              STR      r0,[r1,#0]
;;;14     	I2C_WAIT_READY(I2C0);    
000020  bf00              NOP      
                  |L1.34|
000022  486a              LDR      r0,|L1.460|
000024  6800              LDR      r0,[r0,#0]
000026  f0000008          AND      r0,r0,#8
00002a  2800              CMP      r0,#0
00002c  d0f9              BEQ      |L1.34|
;;;15     
;;;16     	I2C_SetData(I2C0, Device_Addr0 << 1);
00002e  216c              MOVS     r1,#0x6c
000030  4866              LDR      r0,|L1.460|
000032  f7fffffe          BL       I2C_SetData
;;;17     	I2C_SET_CONTROL_REG(I2C0, I2C_CTL_SI);
000036  4865              LDR      r0,|L1.460|
000038  6800              LDR      r0,[r0,#0]
00003a  f020003c          BIC      r0,r0,#0x3c
00003e  f0400008          ORR      r0,r0,#8
000042  4962              LDR      r1,|L1.460|
000044  6008              STR      r0,[r1,#0]
;;;18     	I2C_WAIT_READY(I2C0);  
000046  bf00              NOP      
                  |L1.72|
000048  4860              LDR      r0,|L1.460|
00004a  6800              LDR      r0,[r0,#0]
00004c  f0000008          AND      r0,r0,#8
000050  2800              CMP      r0,#0
000052  d0f9              BEQ      |L1.72|
;;;19     	if (I2C_GetStatus(I2C0) != 0x18)
000054  485d              LDR      r0,|L1.460|
000056  f7fffffe          BL       I2C_GetStatus
00005a  2818              CMP      r0,#0x18
00005c  d00a              BEQ      |L1.116|
;;;20     	{
;;;21     		I2C_SET_CONTROL_REG(I2C0, I2C_CTL_STO| I2C_CTL_SI );
00005e  485b              LDR      r0,|L1.460|
000060  6800              LDR      r0,[r0,#0]
000062  f020003c          BIC      r0,r0,#0x3c
000066  f0400018          ORR      r0,r0,#0x18
00006a  4958              LDR      r1,|L1.460|
00006c  6008              STR      r0,[r1,#0]
;;;22     		return EI2CSLW;
00006e  2006              MOVS     r0,#6
                  |L1.112|
;;;23     	}
;;;24     	for (int i = 0; i<txlen; i++)
;;;25     	{
;;;26     		I2C_SetData(I2C0, pTxData[i]);
;;;27     		I2C_SET_CONTROL_REG(I2C0, I2C_CTL_SI);
;;;28     		I2C_WAIT_READY(I2C0);
;;;29     	}
;;;30     	I2C_SET_CONTROL_REG(I2C0, I2C_CTL_STO |I2C_CTL_SI);
;;;31     	while ((I2C0->CTL0 & I2C_CTL0_STO_Msk) == I2C_CTL0_STO_Msk);
;;;32     	return ENOERR;
;;;33     }
000070  e8bd87f0          POP      {r4-r10,pc}
                  |L1.116|
000074  2400              MOVS     r4,#0                 ;24
000076  e013              B        |L1.160|
                  |L1.120|
000078  5d39              LDRB     r1,[r7,r4]            ;26
00007a  4854              LDR      r0,|L1.460|
00007c  f7fffffe          BL       I2C_SetData
000080  4852              LDR      r0,|L1.460|
000082  6800              LDR      r0,[r0,#0]            ;27
000084  f020003c          BIC      r0,r0,#0x3c           ;27
000088  f0400008          ORR      r0,r0,#8              ;27
00008c  494f              LDR      r1,|L1.460|
00008e  6008              STR      r0,[r1,#0]            ;27
000090  bf00              NOP                            ;28
                  |L1.146|
000092  484e              LDR      r0,|L1.460|
000094  6800              LDR      r0,[r0,#0]            ;28
000096  f0000008          AND      r0,r0,#8              ;28
00009a  2800              CMP      r0,#0                 ;28
00009c  d0f9              BEQ      |L1.146|
00009e  1c64              ADDS     r4,r4,#1              ;24
                  |L1.160|
0000a0  4544              CMP      r4,r8                 ;24
0000a2  d3e9              BCC      |L1.120|
0000a4  4849              LDR      r0,|L1.460|
0000a6  6800              LDR      r0,[r0,#0]            ;30
0000a8  f020003c          BIC      r0,r0,#0x3c           ;30
0000ac  f0400018          ORR      r0,r0,#0x18           ;30
0000b0  4946              LDR      r1,|L1.460|
0000b2  6008              STR      r0,[r1,#0]            ;30
0000b4  bf00              NOP                            ;31
                  |L1.182|
0000b6  4845              LDR      r0,|L1.460|
0000b8  6800              LDR      r0,[r0,#0]            ;31
0000ba  f0000010          AND      r0,r0,#0x10           ;31
0000be  2810              CMP      r0,#0x10              ;31
0000c0  d0f9              BEQ      |L1.182|
0000c2  2000              MOVS     r0,#0                 ;32
0000c4  e7d4              B        |L1.112|
;;;34     
                          ENDP

                  I2C_READ PROC
;;;35     ErrNo I2C_READ(io_handle_t handle, void *buf, uint32 *len)
0000c6  e92d47f0          PUSH     {r4-r10,lr}
;;;36     {
0000ca  4681              MOV      r9,r0
0000cc  460d              MOV      r5,r1
0000ce  4616              MOV      r6,r2
;;;37     	unsigned char *pRxData;
;;;38     	uint32 rxlen = *len;
0000d0  f8d68000          LDR      r8,[r6,#0]
;;;39     	pRxData = (unsigned char *)buf;
0000d4  462f              MOV      r7,r5
;;;40     
;;;41     	I2C_SET_CONTROL_REG(I2C0, I2C_CTL_STA);
0000d6  483d              LDR      r0,|L1.460|
0000d8  6800              LDR      r0,[r0,#0]
0000da  f020003c          BIC      r0,r0,#0x3c
0000de  f0400020          ORR      r0,r0,#0x20
0000e2  493a              LDR      r1,|L1.460|
0000e4  6008              STR      r0,[r1,#0]
;;;42     	I2C_WAIT_READY(I2C0);
0000e6  bf00              NOP      
                  |L1.232|
0000e8  4838              LDR      r0,|L1.460|
0000ea  6800              LDR      r0,[r0,#0]
0000ec  f0000008          AND      r0,r0,#8
0000f0  2800              CMP      r0,#0
0000f2  d0f9              BEQ      |L1.232|
;;;43     
;;;44     	I2C_SetData(I2C0, (Device_Addr0 << 1) | 0x01);
0000f4  216d              MOVS     r1,#0x6d
0000f6  4835              LDR      r0,|L1.460|
0000f8  f7fffffe          BL       I2C_SetData
;;;45     	I2C_SET_CONTROL_REG(I2C0, I2C_CTL_SI);
0000fc  4833              LDR      r0,|L1.460|
0000fe  6800              LDR      r0,[r0,#0]
000100  f020003c          BIC      r0,r0,#0x3c
000104  f0400008          ORR      r0,r0,#8
000108  4930              LDR      r1,|L1.460|
00010a  6008              STR      r0,[r1,#0]
;;;46     	I2C_WAIT_READY(I2C0);
00010c  bf00              NOP      
                  |L1.270|
00010e  482f              LDR      r0,|L1.460|
000110  6800              LDR      r0,[r0,#0]
000112  f0000008          AND      r0,r0,#8
000116  2800              CMP      r0,#0
000118  d0f9              BEQ      |L1.270|
;;;47     	if (I2C_GetStatus(I2C0) != 0x40)
00011a  482c              LDR      r0,|L1.460|
00011c  f7fffffe          BL       I2C_GetStatus
000120  2840              CMP      r0,#0x40
000122  d00a              BEQ      |L1.314|
;;;48     	{
;;;49     		I2C_SET_CONTROL_REG(I2C0, I2C_CTL_STO | I2C_CTL_SI);
000124  4829              LDR      r0,|L1.460|
000126  6800              LDR      r0,[r0,#0]
000128  f020003c          BIC      r0,r0,#0x3c
00012c  f0400018          ORR      r0,r0,#0x18
000130  4926              LDR      r1,|L1.460|
000132  6008              STR      r0,[r1,#0]
;;;50     		return EI2CSLR;
000134  2007              MOVS     r0,#7
                  |L1.310|
;;;51     	}
;;;52     	for (int i = 0; i<rxlen; i++)
;;;53     	{
;;;54     
;;;55     		I2C_SET_CONTROL_REG(I2C0, I2C_CTL_SI | I2C_CTL_AA);
;;;56     		I2C_WAIT_READY(I2C0);
;;;57     		pRxData[i] = I2C_GetData(I2C0);
;;;58     	}
;;;59     	I2C_SET_CONTROL_REG(I2C0, I2C_CTL_STO | I2C_CTL_SI);
;;;60     	while ((I2C0->CTL0 & I2C_CTL0_STO_Msk) == I2C_CTL0_STO_Msk);
;;;61     	return ENOERR;
;;;62     }
000136  e8bd87f0          POP      {r4-r10,pc}
                  |L1.314|
00013a  2400              MOVS     r4,#0                 ;52
00013c  e013              B        |L1.358|
                  |L1.318|
00013e  4823              LDR      r0,|L1.460|
000140  6800              LDR      r0,[r0,#0]            ;55
000142  f020003c          BIC      r0,r0,#0x3c           ;55
000146  f040000c          ORR      r0,r0,#0xc            ;55
00014a  4920              LDR      r1,|L1.460|
00014c  6008              STR      r0,[r1,#0]            ;55
00014e  bf00              NOP                            ;56
                  |L1.336|
000150  481e              LDR      r0,|L1.460|
000152  6800              LDR      r0,[r0,#0]            ;56
000154  f0000008          AND      r0,r0,#8              ;56
000158  2800              CMP      r0,#0                 ;56
00015a  d0f9              BEQ      |L1.336|
00015c  481b              LDR      r0,|L1.460|
00015e  f7fffffe          BL       I2C_GetData
000162  5538              STRB     r0,[r7,r4]            ;57
000164  1c64              ADDS     r4,r4,#1              ;52
                  |L1.358|
000166  4544              CMP      r4,r8                 ;52
000168  d3e9              BCC      |L1.318|
00016a  4818              LDR      r0,|L1.460|
00016c  6800              LDR      r0,[r0,#0]            ;59
00016e  f020003c          BIC      r0,r0,#0x3c           ;59
000172  f0400018          ORR      r0,r0,#0x18           ;59
000176  4915              LDR      r1,|L1.460|
000178  6008              STR      r0,[r1,#0]            ;59
00017a  bf00              NOP                            ;60
                  |L1.380|
00017c  4813              LDR      r0,|L1.460|
00017e  6800              LDR      r0,[r0,#0]            ;60
000180  f0000010          AND      r0,r0,#0x10           ;60
000184  2810              CMP      r0,#0x10              ;60
000186  d0f9              BEQ      |L1.380|
000188  2000              MOVS     r0,#0                 ;61
00018a  e7d4              B        |L1.310|
;;;63     
                          ENDP

                  I2C_Config PROC
;;;64     ErrNo I2C_Config(void *priv)
00018c  b510              PUSH     {r4,lr}
;;;65     {
00018e  4604              MOV      r4,r0
;;;66     	/* Enable I2C0 clock */
;;;67     	CLK_EnableModuleClock(I2C0_MODULE);
000190  480f              LDR      r0,|L1.464|
000192  f7fffffe          BL       CLK_EnableModuleClock
;;;68     	/* Set I2C0 multi-function pins */
;;;69     	SYS->GPA_MFPL = (SYS->GPA_MFPL & ~(SYS_GPA_MFPL_PA4MFP_Msk | SYS_GPA_MFPL_PA5MFP_Msk)) |
000196  f04f4080          MOV      r0,#0x40000000
00019a  6b00              LDR      r0,[r0,#0x30]
00019c  f420007f          BIC      r0,r0,#0xff0000
0001a0  f4400019          ORR      r0,r0,#0x990000
0001a4  f04f4180          MOV      r1,#0x40000000
0001a8  6308              STR      r0,[r1,#0x30]
;;;70     		(SYS_GPA_MFPL_PA4MFP_I2C0_SDA | SYS_GPA_MFPL_PA5MFP_I2C0_SCL);
;;;71     
;;;72     	/* I2C clock pin enable schmitt trigger */
;;;73     	PA->SMTEN |= GPIO_SMTEN_SMTEN5_Msk;
0001aa  f04f2040          MOV      r0,#0x40004000
0001ae  6a40              LDR      r0,[r0,#0x24]
0001b0  f0400020          ORR      r0,r0,#0x20
0001b4  f04f2140          MOV      r1,#0x40004000
0001b8  6248              STR      r0,[r1,#0x24]
;;;74     	/* Open I2C0 and set clock to 100k */
;;;75     	I2C_Open(I2C0, 100000);
0001ba  4906              LDR      r1,|L1.468|
0001bc  4803              LDR      r0,|L1.460|
0001be  f7fffffe          BL       I2C_Open
;;;76     		return 0;
0001c2  2000              MOVS     r0,#0
;;;77     }
0001c4  bd10              POP      {r4,pc}
;;;78     
                          ENDP

                  I2C_Package PROC
;;;79     ErrNo I2C_Package(io_handle_t handle, void *buf, uint32 *len)
0001c6  4603              MOV      r3,r0
;;;80     {
;;;81     return ENOERR;
0001c8  2000              MOVS     r0,#0
;;;82     
;;;83     }
0001ca  4770              BX       lr
;;;84     
                          ENDP

                  |L1.460|
                          DCD      0x40080000
                  |L1.464|
                          DCD      0x40000008
                  |L1.468|
                          DCD      0x000186a0

;*** Start embedded assembler ***

#line 1 "..\\ISP_I2C_BUS.C"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_ISP_I2C_BUS_C_97f66fc6____REV16|
#line 388 "..\\..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___13_ISP_I2C_BUS_C_97f66fc6____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_ISP_I2C_BUS_C_97f66fc6____REVSH|
#line 402
|__asm___13_ISP_I2C_BUS_C_97f66fc6____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___13_ISP_I2C_BUS_C_97f66fc6____RRX|
#line 587
|__asm___13_ISP_I2C_BUS_C_97f66fc6____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
