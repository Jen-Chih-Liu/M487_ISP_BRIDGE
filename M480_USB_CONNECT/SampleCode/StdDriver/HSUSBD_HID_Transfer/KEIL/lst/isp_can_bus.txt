; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\obj\isp_can_bus.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\isp_can_bus.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\..\Library\CMSIS\Include -I..\..\..\..\Library\StdDriver\inc -I..\..\..\..\Library\Device\Nuvoton\M480\Include -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 -DDEBUG_ENABLE_SEMIHOST --omf_browse=.\obj\isp_can_bus.crf ..\ISP_CAN_BUS.C]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  CLK_SysTickDelay PROC
;;;512      */
;;;513    __STATIC_INLINE void CLK_SysTickDelay(uint32_t us)
000000  4954              LDR      r1,|L1.340|
;;;514    {
;;;515        SysTick->LOAD = us * CyclesPerUs;
000002  6809              LDR      r1,[r1,#0]  ; CyclesPerUs
000004  4341              MULS     r1,r0,r1
000006  f04f22e0          MOV      r2,#0xe000e000
00000a  6151              STR      r1,[r2,#0x14]
;;;516        SysTick->VAL  = 0x0UL;
00000c  2100              MOVS     r1,#0
00000e  6191              STR      r1,[r2,#0x18]
;;;517        SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
000010  2105              MOVS     r1,#5
000012  6111              STR      r1,[r2,#0x10]
;;;518    
;;;519        /* Waiting for down-count to zero */
;;;520        while((SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) == 0UL)
000014  bf00              NOP      
                  |L1.22|
000016  f04f21e0          MOV      r1,#0xe000e000
00001a  6909              LDR      r1,[r1,#0x10]
00001c  f4013180          AND      r1,r1,#0x10000
000020  2900              CMP      r1,#0
000022  d0f8              BEQ      |L1.22|
;;;521        {
;;;522        }
;;;523    
;;;524        /* Disable SysTick counter */
;;;525        SysTick->CTRL = 0UL;
000024  2100              MOVS     r1,#0
000026  f04f22e0          MOV      r2,#0xe000e000
00002a  6111              STR      r1,[r2,#0x10]
;;;526    }
00002c  4770              BX       lr
;;;527    
                          ENDP

                  CAN_WRITE PROC
;;;8      #define CAN_ID_ISP_TX 0X102
;;;9      ErrNo CAN_WRITE(io_handle_t handle, const void *buf, uint32 *len)
00002e  e92d43f0          PUSH     {r4-r9,lr}
;;;10     {
000032  b087              SUB      sp,sp,#0x1c
000034  4680              MOV      r8,r0
000036  460d              MOV      r5,r1
000038  4691              MOV      r9,r2
;;;11     	uint8_t *pTxData;
;;;12     	//uint32 txlen=*len;
;;;13     uint8_t i;
;;;14     	pTxData = (uint8_t *)buf;
00003a  462e              MOV      r6,r5
;;;15     	
;;;16     	STR_CANMSG_T tMsg;
;;;17     	CAN_T *tCAN;
;;;18     	tCAN = (CAN_T *)CAN0;
00003c  4f46              LDR      r7,|L1.344|
;;;19     
;;;20     	for (i = 0; i<8; i++)
00003e  2400              MOVS     r4,#0
000040  e01f              B        |L1.130|
                  |L1.66|
;;;21     	{
;;;22     		tMsg.FrameType = CAN_DATA_FRAME;
000042  2001              MOVS     r0,#1
000044  9002              STR      r0,[sp,#8]
;;;23     	  tMsg.IdType = CAN_STD_ID;
000046  2000              MOVS     r0,#0
000048  9001              STR      r0,[sp,#4]
;;;24     	  tMsg.DLC = 8;
00004a  2008              MOVS     r0,#8
00004c  f88d0010          STRB     r0,[sp,#0x10]
;;;25     	  tMsg.Id = CAN_ID_ISP_TX;
000050  f44f7081          MOV      r0,#0x102
000054  9003              STR      r0,[sp,#0xc]
;;;26     		memcpy(&tMsg.Data[0], &pTxData[i << 3], 8);
000056  eb0600c4          ADD      r0,r6,r4,LSL #3
00005a  6801              LDR      r1,[r0,#0]
00005c  f8cd1011          STR      r1,[sp,#0x11]
000060  6840              LDR      r0,[r0,#4]
000062  f8cd0015          STR      r0,[sp,#0x15]
;;;27     		CAN_Transmit(tCAN, MSG(i), &tMsg);
000066  aa01              ADD      r2,sp,#4
000068  4621              MOV      r1,r4
00006a  4638              MOV      r0,r7
00006c  f7fffffe          BL       CAN_Transmit
;;;28     		CLK_SysTickDelay(200);
000070  20c8              MOVS     r0,#0xc8
000072  f7fffffe          BL       CLK_SysTickDelay
;;;29     		CAN_CLR_INT_PENDING_BIT(tCAN,i);
000076  4621              MOV      r1,r4
000078  4638              MOV      r0,r7
00007a  f7fffffe          BL       CAN_CLR_INT_PENDING_BIT
00007e  1c60              ADDS     r0,r4,#1              ;20
000080  b2c4              UXTB     r4,r0                 ;20
                  |L1.130|
000082  2c08              CMP      r4,#8                 ;20
000084  dbdd              BLT      |L1.66|
;;;30     	}
;;;31     	return ENOERR;
000086  2000              MOVS     r0,#0
;;;32     }
000088  b007              ADD      sp,sp,#0x1c
00008a  e8bd83f0          POP      {r4-r9,pc}
;;;33     
                          ENDP

                  CAN_READ PROC
;;;34     ErrNo CAN_READ(io_handle_t handle, void *buf, uint32 *len)
00008e  e92d43f0          PUSH     {r4-r9,lr}
;;;35     {
000092  b087              SUB      sp,sp,#0x1c
000094  4680              MOV      r8,r0
000096  460e              MOV      r6,r1
000098  4691              MOV      r9,r2
;;;36     	uint8_t *pRxData;
;;;37     	//uint32 rxlen = *len;
;;;38     
;;;39     	pRxData = (uint8_t *)buf;
00009a  4637              MOV      r7,r6
;;;40     	uint8_t int_count;
;;;41     	STR_CANMSG_T rrMsg;
;;;42     			CAN_T *tCAN;
;;;43     	tCAN = (CAN_T *)CAN0;
00009c  4d2e              LDR      r5,|L1.344|
;;;44     
;;;45     	int_count = 1;
00009e  2401              MOVS     r4,#1
;;;46       while (tCAN->IIDR == 0){}; 
0000a0  bf00              NOP      
                  |L1.162|
0000a2  6928              LDR      r0,[r5,#0x10]
0000a4  2800              CMP      r0,#0
0000a6  d0fc              BEQ      |L1.162|
;;;47     	  CLK_SysTickDelay(2000);
0000a8  f44f60fa          MOV      r0,#0x7d0
0000ac  f7fffffe          BL       CLK_SysTickDelay
;;;48     	while (1) {
0000b0  e013              B        |L1.218|
                  |L1.178|
;;;49     		                 /* Wait IDR is changed */
;;;50     												  //printf("IDR = %x\n", tCAN->IIDR);
;;;51     		CAN_Receive(tCAN, tCAN->IIDR - 1, &rrMsg); /* Get the message */
0000b2  6928              LDR      r0,[r5,#0x10]
0000b4  1e41              SUBS     r1,r0,#1
0000b6  aa01              ADD      r2,sp,#4
0000b8  4628              MOV      r0,r5
0000ba  f7fffffe          BL       CAN_Receive
;;;52     												   //CAN_ShowMsg(&rrMsg);                     /* Show the message object */
;;;53     		memcpy(&pRxData[(int_count - 1) * 8], &rrMsg.Data[0], 8);
0000be  1e60              SUBS     r0,r4,#1
0000c0  eb0700c0          ADD      r0,r7,r0,LSL #3
0000c4  f8dd1011          LDR      r1,[sp,#0x11]
0000c8  6001              STR      r1,[r0,#0]
0000ca  f8dd1015          LDR      r1,[sp,#0x15]
0000ce  6041              STR      r1,[r0,#4]
;;;54     		int_count++;
0000d0  1c60              ADDS     r0,r4,#1
0000d2  b2c4              UXTB     r4,r0
;;;55     		if (int_count>8)
0000d4  2c08              CMP      r4,#8
0000d6  dd00              BLE      |L1.218|
;;;56     			break;
0000d8  e000              B        |L1.220|
                  |L1.218|
0000da  e7ea              B        |L1.178|
                  |L1.220|
0000dc  bf00              NOP      
;;;57     	}
;;;58     	return ENOERR;
0000de  2000              MOVS     r0,#0
;;;59     }
0000e0  b007              ADD      sp,sp,#0x1c
0000e2  e8bd83f0          POP      {r4-r9,pc}
;;;60     
                          ENDP

                  CAN_Config PROC
;;;61     ErrNo CAN_Config(void *priv)
0000e6  b5f8              PUSH     {r3-r7,lr}
;;;62     {
0000e8  4606              MOV      r6,r0
;;;63     			CAN_T *tCAN;
;;;64     	tCAN = (CAN_T *)CAN0;
0000ea  4d1b              LDR      r5,|L1.344|
;;;65     
;;;66     	/* Enable CAN module clock */
;;;67     	CLK_EnableModuleClock(CAN0_MODULE);
0000ec  481b              LDR      r0,|L1.348|
0000ee  f7fffffe          BL       CLK_EnableModuleClock
;;;68     	    /* Set PA multi-function pins for CAN0 RXD(PA.4) and TXD(PA.5) */
;;;69         SYS->GPA_MFPL = (SYS->GPA_MFPL & ~(SYS_GPA_MFPL_PA4MFP_Msk | SYS_GPA_MFPL_PA5MFP_Msk)) |
0000f2  0368              LSLS     r0,r5,#13
0000f4  6b00              LDR      r0,[r0,#0x30]
0000f6  f420007f          BIC      r0,r0,#0xff0000
0000fa  f440002a          ORR      r0,r0,#0xaa0000
0000fe  0369              LSLS     r1,r5,#13
000100  6308              STR      r0,[r1,#0x30]
;;;70                         (SYS_GPA_MFPL_PA4MFP_CAN0_RXD | SYS_GPA_MFPL_PA5MFP_CAN0_TXD);
;;;71     	CAN_Open(tCAN, 1000000, CAN_NORMAL_MODE);
000102  2200              MOVS     r2,#0
000104  4916              LDR      r1,|L1.352|
000106  4628              MOV      r0,r5
000108  f7fffffe          BL       CAN_Open
;;;72     		for(int i=8;i<15;i++)
00010c  2408              MOVS     r4,#8
00010e  e009              B        |L1.292|
                  |L1.272|
;;;73     	CAN_SetRxMsgObj(tCAN, MSG(i), CAN_STD_ID, CAN_ID_ISP_RX, FALSE);
000110  2000              MOVS     r0,#0
000112  b2e1              UXTB     r1,r4
000114  f44f7380          MOV      r3,#0x100
000118  4602              MOV      r2,r0
00011a  9000              STR      r0,[sp,#0]
00011c  4628              MOV      r0,r5
00011e  f7fffffe          BL       CAN_SetRxMsgObj
000122  1c64              ADDS     r4,r4,#1              ;72
                  |L1.292|
000124  2c0f              CMP      r4,#0xf               ;72
000126  dbf3              BLT      |L1.272|
;;;74     	CAN_SetRxMsg(tCAN, MSG(15), CAN_STD_ID, CAN_ID_ISP_RX); //FOR LAST CAN PACKAGE
000128  f44f7380          MOV      r3,#0x100
00012c  2200              MOVS     r2,#0
00012e  210f              MOVS     r1,#0xf
000130  4628              MOV      r0,r5
000132  f7fffffe          BL       CAN_SetRxMsg
;;;75     	//control high speed
;;;76         /* Set CAN transceiver to high speed mode */
;;;77         GPIO_SetMode(PA, (BIT2 | BIT3), GPIO_MODE_OUTPUT);
000136  2201              MOVS     r2,#1
000138  210c              MOVS     r1,#0xc
00013a  f04f2040          MOV      r0,#0x40004000
00013e  f7fffffe          BL       GPIO_SetMode
;;;78         PA2 = 0;
000142  2000              MOVS     r0,#0
000144  4907              LDR      r1,|L1.356|
000146  6008              STR      r0,[r1,#0]
;;;79         PA3 = 0;
000148  1d09              ADDS     r1,r1,#4
00014a  6008              STR      r0,[r1,#0]
;;;80     	return ENOERR;
;;;81     }
00014c  bdf8              POP      {r3-r7,pc}
;;;82     ErrNo CAN_Package(io_handle_t handle, void *buf, uint32 *len)
                          ENDP

                  CAN_Package PROC
00014e  4603              MOV      r3,r0
;;;83     {
;;;84     return ENOERR;
000150  2000              MOVS     r0,#0
;;;85     }
000152  4770              BX       lr
;;;86     
                          ENDP

                  |L1.340|
                          DCD      CyclesPerUs
                  |L1.344|
                          DCD      0x400a0000
                  |L1.348|
                          DCD      0x40000018
                  |L1.352|
                          DCD      0x000f4240
                  |L1.356|
                          DCD      0x40004808

;*** Start embedded assembler ***

#line 1 "..\\ISP_CAN_BUS.C"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_ISP_CAN_BUS_C_41d012eb____REV16|
#line 388 "..\\..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___13_ISP_CAN_BUS_C_41d012eb____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_ISP_CAN_BUS_C_41d012eb____REVSH|
#line 402
|__asm___13_ISP_CAN_BUS_C_41d012eb____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___13_ISP_CAN_BUS_C_41d012eb____RRX|
#line 587
|__asm___13_ISP_CAN_BUS_C_41d012eb____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
