; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\obj\isp_uart_bus.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\isp_uart_bus.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\..\Library\CMSIS\Include -I..\..\..\..\Library\StdDriver\inc -I..\..\..\..\Library\Device\Nuvoton\M480\Include -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 -DDEBUG_ENABLE_SEMIHOST --omf_browse=.\obj\isp_uart_bus.crf ..\ISP_UART_BUS.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  SendChar_ToUART0 PROC
;;;5      #define uart_timeout   10
;;;6      void SendChar_ToUART0(uint8_t u8InChar)
000000  bf00              NOP      
                  |L1.2|
;;;7      {
;;;8          while(UART_IS_TX_FULL(UART0)){};  /* Wait Tx is not full to transmit data */
000002  4952              LDR      r1,|L1.332|
000004  6989              LDR      r1,[r1,#0x18]
000006  f3c151c0          UBFX     r1,r1,#23,#1
00000a  2900              CMP      r1,#0
00000c  d1f9              BNE      |L1.2|
;;;9                UART_WRITE(UART0, u8InChar);
00000e  494f              LDR      r1,|L1.332|
000010  6008              STR      r0,[r1,#0]
;;;10     	  while(UART_IS_TX_EMPTY(UART0)==0);  /* Wait Tx is not full to transmit data */
000012  bf00              NOP      
                  |L1.20|
000014  494d              LDR      r1,|L1.332|
000016  6989              LDR      r1,[r1,#0x18]
000018  f3c17100          UBFX     r1,r1,#28,#1
00001c  2900              CMP      r1,#0
00001e  d0f9              BEQ      |L1.20|
;;;11     }
000020  4770              BX       lr
;;;12     
                          ENDP

                  ISP_UART_WRITE PROC
;;;13     
;;;14     ErrNo ISP_UART_WRITE(io_handle_t handle, const void *buf, uint32 *len)
000022  b5f0              PUSH     {r4-r7,lr}
;;;15     {
000024  4607              MOV      r7,r0
000026  460b              MOV      r3,r1
000028  4614              MOV      r4,r2
;;;16     	uint8_t *pTxData;
;;;17     	uint32 txlen=*len;
00002a  6826              LDR      r6,[r4,#0]
;;;18     	pTxData = (uint8_t *)buf;
00002c  461d              MOV      r5,r3
;;;19     	for (int i = 0; i < txlen; i++)
00002e  2200              MOVS     r2,#0
000030  e003              B        |L1.58|
                  |L1.50|
;;;20     	     SendChar_ToUART0(pTxData[i]);		
000032  5ca8              LDRB     r0,[r5,r2]
000034  f7fffffe          BL       SendChar_ToUART0
000038  1c52              ADDS     r2,r2,#1              ;19
                  |L1.58|
00003a  42b2              CMP      r2,r6                 ;19
00003c  d3f9              BCC      |L1.50|
;;;21     	return ENOERR;
00003e  2000              MOVS     r0,#0
;;;22     }
000040  bdf0              POP      {r4-r7,pc}
;;;23     
                          ENDP

                  ISP_UART_READ PROC
;;;24     ErrNo ISP_UART_READ(io_handle_t handle, void *buf, uint32 *len)
000042  e92d47f0          PUSH     {r4-r10,lr}
;;;25     {
000046  4682              MOV      r10,r0
000048  460d              MOV      r5,r1
00004a  4616              MOV      r6,r2
;;;26     	
;;;27     	uint8_t *pRxData;
;;;28     	uint32 rxlen = *len;
00004c  f8d69000          LDR      r9,[r6,#0]
;;;29     	pRxData = (uint8_t *)buf;
000050  46a8              MOV      r8,r5
;;;30     	uint32_t time_count=0;
000052  2700              MOVS     r7,#0
;;;31     	TIMER_Open(TIMER0, TIMER_PERIODIC_MODE, 1);
000054  2201              MOVS     r2,#1
000056  06d1              LSLS     r1,r2,#27
000058  483d              LDR      r0,|L1.336|
00005a  f7fffffe          BL       TIMER_Open
;;;32       TIMER_Start(TIMER0);
00005e  bf00              NOP      
000060  483b              LDR      r0,|L1.336|
000062  6800              LDR      r0,[r0,#0]
000064  f0404080          ORR      r0,r0,#0x40000000
000068  4939              LDR      r1,|L1.336|
00006a  6008              STR      r0,[r1,#0]
00006c  bf00              NOP      
;;;33     	for (int i = 0; i < rxlen; i++)
00006e  2400              MOVS     r4,#0
000070  e021              B        |L1.182|
                  |L1.114|
;;;34        {
;;;35     		 while(1)
000072  e01d              B        |L1.176|
                  |L1.116|
;;;36     		 {
;;;37     		 if(UART_IS_RX_READY(UART0))
000074  4835              LDR      r0,|L1.332|
000076  69c0              LDR      r0,[r0,#0x1c]
000078  f0000001          AND      r0,r0,#1
00007c  b120              CBZ      r0,|L1.136|
;;;38     		 {
;;;39     		 pRxData[i]=UART_READ(UART0);
00007e  4833              LDR      r0,|L1.332|
000080  6800              LDR      r0,[r0,#0]
000082  f8080004          STRB     r0,[r8,r4]
;;;40     			 break;
000086  e014              B        |L1.178|
                  |L1.136|
;;;41     		 }
;;;42     		 
;;;43     		if(TIMER_GetIntFlag(TIMER0))
000088  bf00              NOP      
00008a  4831              LDR      r0,|L1.336|
00008c  6880              LDR      r0,[r0,#8]
00008e  f0000001          AND      r0,r0,#1
000092  b168              CBZ      r0,|L1.176|
;;;44     			 {
;;;45     				
;;;46     		/* Clear Timer0 time-out interrupt flag */
;;;47             TIMER_ClearIntFlag(TIMER0);
000094  bf00              NOP      
000096  2001              MOVS     r0,#1
000098  492d              LDR      r1,|L1.336|
00009a  6088              STR      r0,[r1,#8]
00009c  bf00              NOP      
;;;48     				time_count++;
00009e  1c7f              ADDS     r7,r7,#1
;;;49     				if(time_count>=uart_timeout) 
0000a0  2f0a              CMP      r7,#0xa
0000a2  d305              BCC      |L1.176|
;;;50     				{
;;;51     					TIMER_Stop(TIMER0);
0000a4  4608              MOV      r0,r1
0000a6  f7fffffe          BL       TIMER_Stop
;;;52     					return ETO; //THIS IS TIMEOUT ERROR
0000aa  2005              MOVS     r0,#5
                  |L1.172|
;;;53     		   } 
;;;54     		 
;;;55     	 }
;;;56      }
;;;57     		 }
;;;58     
;;;59     TIMER_Stop(TIMER0);
;;;60        
;;;61     	return ENOERR;
;;;62     }
0000ac  e8bd87f0          POP      {r4-r10,pc}
                  |L1.176|
0000b0  e7e0              B        |L1.116|
                  |L1.178|
0000b2  bf00              NOP                            ;40
0000b4  1c64              ADDS     r4,r4,#1              ;33
                  |L1.182|
0000b6  454c              CMP      r4,r9                 ;33
0000b8  d3db              BCC      |L1.114|
0000ba  4825              LDR      r0,|L1.336|
0000bc  f7fffffe          BL       TIMER_Stop
0000c0  2000              MOVS     r0,#0                 ;61
0000c2  e7f3              B        |L1.172|
;;;63     
                          ENDP

                  UART_Config PROC
;;;65     
;;;66     ErrNo UART_Config(void *priv)
0000c4  b510              PUSH     {r4,lr}
;;;67     {
0000c6  4604              MOV      r4,r0
;;;68     		    /* Enable UART module clock */
;;;69         CLK_EnableModuleClock(UART0_MODULE);
0000c8  4822              LDR      r0,|L1.340|
0000ca  f7fffffe          BL       CLK_EnableModuleClock
;;;70     
;;;71     
;;;72         /* Select UART clock source is HXT */
;;;73         CLK->CLKSEL1 = (CLK->CLKSEL1 & ~CLK_CLKSEL1_UART0SEL_Msk) | (0x0 << CLK_CLKSEL1_UART0SEL_Pos);
0000ce  4822              LDR      r0,|L1.344|
0000d0  6800              LDR      r0,[r0,#0]
0000d2  f0207040          BIC      r0,r0,#0x3000000
0000d6  f04f4180          MOV      r1,#0x40000000
0000da  f8c10214          STR      r0,[r1,#0x214]
;;;74     
;;;75         /* Set GPB multi-function pins for UART0 RXD and TXD */
;;;76         SYS->GPB_MFPH &= ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk);
0000de  4608              MOV      r0,r1
0000e0  6bc0              LDR      r0,[r0,#0x3c]
0000e2  f420007f          BIC      r0,r0,#0xff0000
0000e6  63c8              STR      r0,[r1,#0x3c]
;;;77         SYS->GPB_MFPH |= (SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);
0000e8  4608              MOV      r0,r1
0000ea  6bc0              LDR      r0,[r0,#0x3c]
0000ec  f44000cc          ORR      r0,r0,#0x660000
0000f0  63c8              STR      r0,[r1,#0x3c]
;;;78     		    /* Configure UART0 and set UART0 baud rate */
;;;79         UART_Open(UART0, 115200);
0000f2  f44f31e1          MOV      r1,#0x1c200
0000f6  4815              LDR      r0,|L1.332|
0000f8  f7fffffe          BL       UART_Open
;;;80     	    CLK_EnableModuleClock(TMR0_MODULE);
0000fc  4817              LDR      r0,|L1.348|
0000fe  f7fffffe          BL       CLK_EnableModuleClock
;;;81     
;;;82         /* Select IP clock source */
;;;83         CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_HXT, CLK_CLKDIV0_UART0(1));
000102  2200              MOVS     r2,#0
000104  4611              MOV      r1,r2
000106  4813              LDR      r0,|L1.340|
000108  f7fffffe          BL       CLK_SetModuleClock
;;;84         CLK_SetModuleClock(TMR0_MODULE, CLK_CLKSEL1_TMR0SEL_HXT, 0);
00010c  2200              MOVS     r2,#0
00010e  4611              MOV      r1,r2
000110  4812              LDR      r0,|L1.348|
000112  f7fffffe          BL       CLK_SetModuleClock
;;;85     	  return ENOERR;
000116  2000              MOVS     r0,#0
;;;86     }
000118  bd10              POP      {r4,pc}
;;;87     
                          ENDP

                  ISP_UART_Package PROC
;;;88     ErrNo ISP_UART_Package(io_handle_t handle, uint8_t *in_buf, uint32_t *in_len,uint8_t *out_buf, uint32_t *out_len)
00011a  e92d41f0          PUSH     {r4-r8,lr}
;;;89     {
00011e  4605              MOV      r5,r0
000120  460e              MOV      r6,r1
000122  4617              MOV      r7,r2
000124  461c              MOV      r4,r3
000126  f8dd8018          LDR      r8,[sp,#0x18]
;;;90     	ISP_UART_WRITE(handle,out_buf,out_len);
00012a  4642              MOV      r2,r8
00012c  4621              MOV      r1,r4
00012e  4628              MOV      r0,r5
000130  f7fffffe          BL       ISP_UART_WRITE
;;;91     	return ISP_UART_READ(handle,in_buf,in_len);
000134  463a              MOV      r2,r7
000136  4631              MOV      r1,r6
000138  4628              MOV      r0,r5
00013a  f7fffffe          BL       ISP_UART_READ
;;;92      
;;;93     
;;;94     }
00013e  e8bd81f0          POP      {r4-r8,pc}
;;;95     
                          ENDP

                  TIMER_Stop PROC
;;;169      */
;;;170    __STATIC_INLINE void TIMER_Stop(TIMER_T *timer)
000142  6801              LDR      r1,[r0,#0]
;;;171    {
;;;172        timer->CTL &= ~TIMER_CTL_CNTEN_Msk;
000144  f0214180          BIC      r1,r1,#0x40000000
000148  6001              STR      r1,[r0,#0]
;;;173    }
00014a  4770              BX       lr
;;;174    
                          ENDP

                  |L1.332|
                          DCD      0x40070000
                  |L1.336|
                          DCD      0x40050000
                  |L1.340|
                          DCD      0x57803d10
                  |L1.344|
                          DCD      0x40000214
                  |L1.348|
                          DCD      0x5e800002

;*** Start embedded assembler ***

#line 1 "..\\ISP_UART_BUS.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_ISP_UART_BUS_c_5e568c2a____REV16|
#line 388 "..\\..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___14_ISP_UART_BUS_c_5e568c2a____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_ISP_UART_BUS_c_5e568c2a____REVSH|
#line 402
|__asm___14_ISP_UART_BUS_c_5e568c2a____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___14_ISP_UART_BUS_c_5e568c2a____RRX|
#line 587
|__asm___14_ISP_UART_BUS_c_5e568c2a____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
