; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\obj\isp_spi_bus.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\isp_spi_bus.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\..\Library\CMSIS\Include -I..\..\..\..\Library\StdDriver\inc -I..\..\..\..\Library\Device\Nuvoton\M480\Include -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 -DDEBUG_ENABLE_SEMIHOST --omf_browse=.\obj\isp_spi_bus.crf ..\ISP_SPI_BUS.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  CLK_SysTickDelay PROC
;;;512      */
;;;513    __STATIC_INLINE void CLK_SysTickDelay(uint32_t us)
000000  4955              LDR      r1,|L1.344|
;;;514    {
;;;515        SysTick->LOAD = us * CyclesPerUs;
000002  6809              LDR      r1,[r1,#0]  ; CyclesPerUs
000004  4341              MULS     r1,r0,r1
000006  f04f22e0          MOV      r2,#0xe000e000
00000a  6151              STR      r1,[r2,#0x14]
;;;516        SysTick->VAL  = 0x0UL;
00000c  2100              MOVS     r1,#0
00000e  6191              STR      r1,[r2,#0x18]
;;;517        SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
000010  2105              MOVS     r1,#5
000012  6111              STR      r1,[r2,#0x10]
;;;518    
;;;519        /* Waiting for down-count to zero */
;;;520        while((SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) == 0UL)
000014  bf00              NOP      
                  |L1.22|
000016  f04f21e0          MOV      r1,#0xe000e000
00001a  6909              LDR      r1,[r1,#0x10]
00001c  f4013180          AND      r1,r1,#0x10000
000020  2900              CMP      r1,#0
000022  d0f8              BEQ      |L1.22|
;;;521        {
;;;522        }
;;;523    
;;;524        /* Disable SysTick counter */
;;;525        SysTick->CTRL = 0UL;
000024  2100              MOVS     r1,#0
000026  f04f22e0          MOV      r2,#0xe000e000
00002a  6111              STR      r1,[r2,#0x10]
;;;526    }
00002c  4770              BX       lr
;;;527    
                          ENDP

                  SPI_WRITE PROC
;;;7      
;;;8      ErrNo SPI_WRITE(io_handle_t handle, const void *buf, uint32 *len)
00002e  e92d47f0          PUSH     {r4-r10,lr}
;;;9      {
000032  4681              MOV      r9,r0
000034  460d              MOV      r5,r1
000036  4616              MOV      r6,r2
;;;10     	uint8_t  *pTxData;
;;;11     	uint32 txlen=*len;
000038  6837              LDR      r7,[r6,#0]
;;;12     	pTxData = (uint8_t *)buf;
00003a  46a8              MOV      r8,r5
;;;13     SPI_ClearRxFIFO(SPI0);
00003c  4847              LDR      r0,|L1.348|
00003e  f7fffffe          BL       SPI_ClearRxFIFO
;;;14     	SPI_ClearTxFIFO(SPI0);
000042  4846              LDR      r0,|L1.348|
000044  f7fffffe          BL       SPI_ClearTxFIFO
;;;15     	for (int i = 0; i<txlen; i++)
000048  2400              MOVS     r4,#0
00004a  e01a              B        |L1.130|
                  |L1.76|
;;;16     	{
;;;17     		/* Write to TX register */
;;;18     		SPI_WRITE_TX(SPI0, pTxData[i]);
00004c  f8180004          LDRB     r0,[r8,r4]
000050  4942              LDR      r1,|L1.348|
000052  6208              STR      r0,[r1,#0x20]
;;;19     		CLK_SysTickDelay(300);
000054  f44f7096          MOV      r0,#0x12c
000058  f7fffffe          BL       CLK_SysTickDelay
;;;20     		/* Check SPI0 busy status */
;;;21     		while (SPI_IS_BUSY(SPI0));
00005c  bf00              NOP      
                  |L1.94|
00005e  483f              LDR      r0,|L1.348|
000060  6940              LDR      r0,[r0,#0x14]
000062  f0000001          AND      r0,r0,#1
000066  2800              CMP      r0,#0
000068  d1f9              BNE      |L1.94|
;;;22     		while (SPI_GET_TX_FIFO_EMPTY_FLAG(SPI0)==0);
00006a  bf00              NOP      
                  |L1.108|
00006c  483b              LDR      r0,|L1.348|
00006e  6940              LDR      r0,[r0,#0x14]
000070  f3c04000          UBFX     r0,r0,#16,#1
000074  2800              CMP      r0,#0
000076  d0f9              BEQ      |L1.108|
;;;23     		CLK_SysTickDelay(300);
000078  f44f7096          MOV      r0,#0x12c
00007c  f7fffffe          BL       CLK_SysTickDelay
000080  1c64              ADDS     r4,r4,#1              ;15
                  |L1.130|
000082  42bc              CMP      r4,r7                 ;15
000084  d3e2              BCC      |L1.76|
;;;24     	}
;;;25     	//CLK_SysTickDelay(500);
;;;26     	return ENOERR;
000086  2000              MOVS     r0,#0
;;;27     }
000088  e8bd87f0          POP      {r4-r10,pc}
;;;28     
                          ENDP

                  SPI_READ PROC
;;;29     ErrNo SPI_READ(io_handle_t handle, void *buf, uint32 *len)
00008c  e92d47f0          PUSH     {r4-r10,lr}
;;;30     {
000090  4681              MOV      r9,r0
000092  460d              MOV      r5,r1
000094  4616              MOV      r6,r2
;;;31     	unsigned char *pRxData;
;;;32     	uint32 rxlen = *len;
000096  f8d68000          LDR      r8,[r6,#0]
;;;33     		CLK_SysTickDelay(5000);
00009a  f2413088          MOV      r0,#0x1388
00009e  f7fffffe          BL       CLK_SysTickDelay
;;;34     	pRxData = (unsigned char *)buf;
0000a2  462f              MOV      r7,r5
;;;35       //CLEAR SPI TX AND RX FIFO	
;;;36     SPI_ClearRxFIFO(SPI0);
0000a4  482d              LDR      r0,|L1.348|
0000a6  f7fffffe          BL       SPI_ClearRxFIFO
;;;37     	SPI_ClearTxFIFO(SPI0);
0000aa  482c              LDR      r0,|L1.348|
0000ac  f7fffffe          BL       SPI_ClearTxFIFO
;;;38     	for (int i = 0; i<rxlen; i++)
0000b0  2400              MOVS     r4,#0
0000b2  e01c              B        |L1.238|
                  |L1.180|
;;;39     	{
;;;40     		/* Write to TX register */
;;;41     		SPI_WRITE_TX(SPI0, 0xff);
0000b4  20ff              MOVS     r0,#0xff
0000b6  4929              LDR      r1,|L1.348|
0000b8  6208              STR      r0,[r1,#0x20]
;;;42     		CLK_SysTickDelay(300);
0000ba  f44f7096          MOV      r0,#0x12c
0000be  f7fffffe          BL       CLK_SysTickDelay
;;;43     		while (SPI_IS_BUSY(SPI0));
0000c2  bf00              NOP      
                  |L1.196|
0000c4  4825              LDR      r0,|L1.348|
0000c6  6940              LDR      r0,[r0,#0x14]
0000c8  f0000001          AND      r0,r0,#1
0000cc  2800              CMP      r0,#0
0000ce  d1f9              BNE      |L1.196|
;;;44     		while (SPI_GET_TX_FIFO_EMPTY_FLAG(SPI0)==0);
0000d0  bf00              NOP      
                  |L1.210|
0000d2  4822              LDR      r0,|L1.348|
0000d4  6940              LDR      r0,[r0,#0x14]
0000d6  f3c04000          UBFX     r0,r0,#16,#1
0000da  2800              CMP      r0,#0
0000dc  d0f9              BEQ      |L1.210|
;;;45     		pRxData[i] = SPI_READ_RX(SPI0);
0000de  481f              LDR      r0,|L1.348|
0000e0  6b00              LDR      r0,[r0,#0x30]
0000e2  5538              STRB     r0,[r7,r4]
;;;46     		CLK_SysTickDelay(300);
0000e4  f44f7096          MOV      r0,#0x12c
0000e8  f7fffffe          BL       CLK_SysTickDelay
0000ec  1c64              ADDS     r4,r4,#1              ;38
                  |L1.238|
0000ee  4544              CMP      r4,r8                 ;38
0000f0  d3e0              BCC      |L1.180|
;;;47     	}	
;;;48     	CLK_SysTickDelay(5000);
0000f2  f2413088          MOV      r0,#0x1388
0000f6  f7fffffe          BL       CLK_SysTickDelay
;;;49     	return ENOERR;
0000fa  2000              MOVS     r0,#0
;;;50     }
0000fc  e8bd87f0          POP      {r4-r10,pc}
;;;51     
                          ENDP

                  SPI_Config PROC
;;;52     ErrNo SPI_Config(void *priv)
000100  b538              PUSH     {r3-r5,lr}
;;;53     {
000102  4604              MOV      r4,r0
;;;54     
;;;55     
;;;56     	/* Select PCLK0 as the clock source of SPI0 */
;;;57     	CLK_SetModuleClock(SPI0_MODULE, CLK_CLKSEL2_SPI0SEL_PCLK1, MODULE_NoMsk);
000104  2200              MOVS     r2,#0
000106  2120              MOVS     r1,#0x20
000108  4815              LDR      r0,|L1.352|
00010a  f7fffffe          BL       CLK_SetModuleClock
;;;58     
;;;59     
;;;60     	/* Enable SPI0 peripheral clock */
;;;61     	CLK_EnableModuleClock(SPI0_MODULE);
00010e  4814              LDR      r0,|L1.352|
000110  f7fffffe          BL       CLK_EnableModuleClock
;;;62     
;;;63     	/* Setup SPI0 multi-function pins */
;;;64     	SYS->GPA_MFPL |= SYS_GPA_MFPL_PA0MFP_SPI0_MOSI | SYS_GPA_MFPL_PA1MFP_SPI0_MISO | SYS_GPA_MFPL_PA2MFP_SPI0_CLK | SYS_GPA_MFPL_PA3MFP_SPI0_SS;
000114  f04f4080          MOV      r0,#0x40000000
000118  6b00              LDR      r0,[r0,#0x30]
00011a  f2444144          MOV      r1,#0x4444
00011e  4308              ORRS     r0,r0,r1
000120  0709              LSLS     r1,r1,#28
000122  6308              STR      r0,[r1,#0x30]
;;;65     
;;;66     	/* Enable SPI0 clock pin (PA2) schmitt trigger */
;;;67     	PA->SMTEN |= GPIO_SMTEN_SMTEN2_Msk;
000124  f04f2040          MOV      r0,#0x40004000
000128  6a40              LDR      r0,[r0,#0x24]
00012a  f0400004          ORR      r0,r0,#4
00012e  f04f2140          MOV      r1,#0x40004000
000132  6248              STR      r0,[r1,#0x24]
;;;68       /* Configure as a master, clock idle low, 8-bit transaction, drive output on falling clock edge and latch input on rising edge. */
;;;69         /* Set IP clock divider. SPI clock rate = 100kHz */
;;;70     	SPI_Open(SPI0, SPI_MASTER, SPI_MODE_0, 8, 100000);
000134  480b              LDR      r0,|L1.356|
000136  2308              MOVS     r3,#8
000138  2204              MOVS     r2,#4
00013a  2100              MOVS     r1,#0
00013c  9000              STR      r0,[sp,#0]
00013e  4807              LDR      r0,|L1.348|
000140  f7fffffe          BL       SPI_Open
;;;71     /* Enable the automatic hardware slave select function. Select the SS pin and configure as low-active. */
;;;72         SPI_EnableAutoSS(SPI0, SPI_SS, SPI_SS_ACTIVE_LOW);
000144  2200              MOVS     r2,#0
000146  2101              MOVS     r1,#1
000148  4804              LDR      r0,|L1.348|
00014a  f7fffffe          BL       SPI_EnableAutoSS
;;;73     	return ENOERR;
00014e  2000              MOVS     r0,#0
;;;74     }
000150  bd38              POP      {r3-r5,pc}
;;;75     
                          ENDP

                  SPI_Package PROC
;;;76     ErrNo SPI_Package(io_handle_t handle, void *buf, uint32 *len)
000152  4603              MOV      r3,r0
;;;77     {
;;;78     return ENOERR;
000154  2000              MOVS     r0,#0
;;;79     
;;;80     }
000156  4770              BX       lr
;;;81     
                          ENDP

                  |L1.344|
                          DCD      CyclesPerUs
                  |L1.348|
                          DCD      0x40061000
                  |L1.352|
                          DCD      0x6640000d
                  |L1.356|
                          DCD      0x000186a0

;*** Start embedded assembler ***

#line 1 "..\\ISP_SPI_BUS.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_ISP_SPI_BUS_c_98a65fa1____REV16|
#line 388 "..\\..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___13_ISP_SPI_BUS_c_98a65fa1____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_ISP_SPI_BUS_c_98a65fa1____REVSH|
#line 402
|__asm___13_ISP_SPI_BUS_c_98a65fa1____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___13_ISP_SPI_BUS_c_98a65fa1____RRX|
#line 587
|__asm___13_ISP_SPI_BUS_c_98a65fa1____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
